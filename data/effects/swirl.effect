// MIT License

// Copyright (c) 2021 Radegast-FFXIV

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
#include "shared.effect"

//-----------------------------------------------------------------------------
// Uniforms
//-----------------------------------------------------------------------------

// Provided by StreamFX
uniform float4 Time<
	bool automatic = true;
>;
uniform float4 ViewSize<
	bool automatic = true;
>;
uniform texture2d InputA<
	bool automatic = true;
>;

uniform float2 coordinates<
    string name = "Coordinates (X, Y)";
    string description = "Determines the center of the effect.";
    string field_type = "slider";
    float2 step = {0.01, 0.01};
    float2 minimum = {0.0, 0.0};
    float2 maximum = {1.0, 1.0};
> = {0.5, 0.5};

uniform float angle<
    string name = "Angle";
    string description = "The angle in degrees to twist the image.";
    string field_type = "slider";
    float minimum = -1800.0;
    float maximum = 1800.0;
> = 270.0;

uniform float radius<
    string name = "Radius";
    string description = "The radius of the effect.";
    string field_type = "slider";
    float step = 0.01;
    float minimum = 0.0;
    float maximum = 1.0;
> = 0.5;

uniform float tension<
    string name = "Tension";
    string description = "Controls how rapidly the distortion reaches the maximum value.";
    string field_type = "slider";
    float step = 0.01;
    float minimum = 0.0;
    float maximum = 10.0;
> = 1.0;

uniform float aspect_ratio<
    string name = "Aspect Ratio";
    string description = "Adjusts the aspect ratio for the associated distortion.";
    string field_type = "slider";
    float step = 0.01;
    float minimum = -1;
    float maximum = 1;
> = 0.0;

uniform bool animate<
    string name = "Animate";
    string description = "Animates the effect, making it twist back and forth.";
> = false;

uniform bool inverse_angle<
    string name = "Use Inverse Angle";
    string description = "Inverts the angle, making the edges more distorted than the center.";
> = false;

//-----------------------------------------------------------------------------
// Textures
//-----------------------------------------------------------------------------
uniform texture2d swirl_result;

//-----------------------------------------------------------------------------
// Samplers
//-----------------------------------------------------------------------------
sampler_state texture_sampler {
	Filter    = Linear;
	AddressU  = Mirror;
	AddressV  = Mirror;
};

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

float2 swirl_transform (float percent, float2 input_vertex, float2 effect_center) {
    float theta = percent * percent * radians(angle * (animate == true ? sin(Time.x) : 1.0) );
    float s =  sin(theta);
    float c =  cos(theta);
    float2x2 transform = float2x2(
        c, -s,
        s, c
    );
    return mul(transform, input_vertex-effect_center);
}

//-----------------------------------------------------------------------------
// Shaders
//-----------------------------------------------------------------------------
float4 PSSwirl(VertexData vtx) : TARGET {
    VertexData vertex_out;
    vertex_out.pos = vtx.pos;

    float2 effect_center = coordinates/2.0;
    float ar_raw = 1. * ViewSize.y / ViewSize.x;
    float ar = lerp(ar_raw, 1, aspect_ratio);

    vertex_out.uv = 1. * vtx.uv - effect_center;
    
    effect_center.x /= ar;
    vertex_out.uv.x /= ar;
    
    float dist = distance(vertex_out.uv, effect_center);
    if (dist < radius)
    {
        float tension_radius = lerp(radius-dist, radius, tension);
        float percent = (radius-dist) /tension_radius;
        percent = inverse_angle == 0 ? percent : 1 - percent;

        vertex_out.uv = swirl_transform(percent, vertex_out.uv, effect_center);
        vertex_out.uv += (2 * effect_center);
        
        vertex_out.uv.x *= ar;

        return InputA.Sample(texture_sampler, vertex_out.uv);
    }
    else
    {
        return InputA.Sample(texture_sampler, vtx.uv );
    }
}

technique Swirl
{
    pass 
    {
        vertex_shader = DefaultVertexShader(vtx);
        pixel_shader = PSSwirl(vtx);
    }
}